import {
  Game,
  Action,
  Scene,
  Label,
  WebColors,
  GameParameters,
  GameOptions,
  TrialSchema,
  Timer,
  ActivityType,
} from "@m2c2kit/core";
import { Session, } from "@m2c2kit/session";
import { Button, CountdownScene, Instructions } from "@m2c2kit/addons";

class LetterGoNoGo extends Game {
  constructor() {
    /**
     * These are configurable game parameters and their defaults.
     * Each game parameter should have a type, default (this is the default
     * value), and a description.
     */
    const defaultParameters: GameParameters = {
      countdown_duration_ms: {
        default: 3000,
        type: "number",
        description:
          "Duration of the countdown phase, milliseconds. Multiples of 1000 recommended.",
      },
      preparation_duration_ms: {
        type: "number",
        default: 500,
        description: "How long the 'Get Ready' message stays on screen (ms).",
      },
      selection_duration_ms: {
        type: "number",
        default: 1500,
        description: "How long the letter is shown, milliseconds.",
      },
      number_of_trials: {
        type: "integer",
        default: 10,
        description: "How many trials to run.",
      },
      show_fps: {
        type: "boolean",
        default: false,
        description: "Should the FPS be shown?",
      },
    };

    /**
     * This describes all the data that will be generated by the assessment
     * in a single trial. Each variable should have a type and description.
     * If a variable might be null, the type can be an array:
     *   type: ["string", "null"]
     * Object and array types are also allowed, but this example uses only
     * simple types.
     *
     * More advanced schema parameters such as format or enum are optional.
     *
     * At runtime, when a trial completes, the data will be returned to the
     * session with a callback, along with this schema transformed into
     * JSON Schema.
     */
    const cliStarterTrialSchema: TrialSchema = {
      trial_index: {
        type: ["integer", "null"],
        description: "Index of the trial within this assessment, 0-based.",
      },
      presented_letter_text: {
        type: "string",
        description: "The letter that was presented.",
      },
      presented_letter_nogo: {
        type: "boolean",
        description: "The color of the text that was presented.",
      },
      selection_correct: {
        type: "boolean",
        description: "Did the user correctly ignore or click on the button?",
      },
      response_time_ms: {
        type: "number",
        description:
          "How long, in milliseconds, from when the word was presented until the user made a selection.",
      },
    };

    const options: GameOptions = {
      name: "LetterGoNoGo",
      id: "lettergonogo",
      publishUuid: "",
      version: "1.0.0",
      shortDescription:
        "A Letter Go-No Go game.",
      longDescription: `Letter Go-No Go Activity is a cognitive task that measures response \
inhibition and attention. Participants are shown a series of individual \
letters on the screen and must tap a button as quickly as possible when \
any letter except "X" appears. This activity assesses the ability to control \
impulses and maintain focus under time constraints.`,
      uri: "An external link to your assessment repository or informational website.",
      showFps: defaultParameters.show_fps.default,
      /**
       * Actual pixel resolution will be scaled to fit the device, while
       * preserving the aspect ratio. It is important, however, to specify
       * a width and height to obtain the desired aspect ratio. In most
       * cases, you should not change this. 1:2 is a good aspect ratio
       * for modern phones.
       */
      width: 400,
      height: 800,
      trialSchema: cliStarterTrialSchema,
      parameters: defaultParameters,
      /**
       * The Roboto-Regular.ttf font is licensed under the Apache License,
       * and its LICENSE.TXT will be copied as part of the build.
       */
      fonts: [
        {
          fontName: "roboto",
          url: "fonts/roboto/Roboto-Regular.ttf",
        },
      ],
     
    };

    super(options);
  }

  override async initialize() {
    await super.initialize();
    /**
     * Just for convenience, alias the variable game to "this"
     * (even though eslint doesn't like it)
     */
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const game = this;

    /**
     * ************************************************************************
     * Create the trial configuration of all trials.
     * It is often necessary to create the full trial configuration before
     * starting any trials. For example, in the stroop task, one could
     * add game parameters to specify a certain percent of the correct
     * responses are the left versus right buttons. Or, one might want an
     * equal number of trials for each font color.
     */

    interface Letter {
      name: string;
      isnogo: Boolean;
    }

    /**
     * These are the colors that will be used in the game.
     */
    const letters: Letter[] = [
      { name: "X", isnogo: true },
      { name: "V", isnogo: false },
      { name: "Z", isnogo: false },
      { name: "Y", isnogo: false },
      { name: "K", isnogo: false },
      { name: "W", isnogo: false },
    ];

    /**
     * This completely describes the configuration of single trial.
     */
    interface TrialConfiguration {
      presented_letter: string;
      presented_isnogo: Boolean;
    }

    const trialConfigurations: TrialConfiguration[] = [];

    /**
     * Note: TypeScript will try to infer the type of the game parameter that
     * you request in game.getParameter(). If the type cannot be inferred, you
     * will get a compiler error, and you must specify the type, as in the
     * next statement.
     */
    for (let i = 0; i < game.getParameter<number>("number_of_trials"); i++) {
      const randIdx =  Math.floor(Math.random() * (letters.length + 2));
      /*from 0 to n inclusive so we can double the chance of nogo*/

      const letter =  randIdx < letters.length ? letters[randIdx] : letters[0]

      trialConfigurations.push({
        presented_letter: letter.name,
        presented_isnogo: letter.isnogo,
      });
    }

    /**
     * For nodes that are persistent across trials, such as the
     * scenes themselves and labels that are always displayed on the scenes,
     * create them here within the initialize() scope.
     */

    /**
     * ************************************************************************
     * Scenes: instructions.
     */
    const instructionsScenes = Instructions.create({
      instructionScenes: [
        {
          title: "Letter Go-No Go",
          text: `Press the circle with the letter inside if the letter is NOT X. Otherwise, ignore.`,
          textFontSize: 20,
          titleFontSize: 30,
          nextButtonText: "START",
          nextButtonBackgroundColor: WebColors.Green,
        },
      ],
    });
    game.addScenes(instructionsScenes);

    /**
     * ************************************************************************
     * Scene: countdown. Show countdown for countdown_duration_ms milliseconds
     */
    const countdownScene = new CountdownScene({
      milliseconds: game.getParameter<number>("countdown_duration_ms"),
      // suppress the default countdown text
      text: "",
    });
    game.addScene(countdownScene);


    /**
     * ************************************************************************
     * Scene: preparation. Show get ready message, then advance after
     * preparation_duration_ms milliseconds
     */
    const preparationScene = new Scene();
    game.addScene(preparationScene);

    const getReadyMessage = new Label({
      text: "Get Ready",
      fontSize: 24,
      position: { x: 200, y: 400 },
    });
    preparationScene.addChild(getReadyMessage);

    /**
     * For nodes that are displayed or actions that are run only when a
     * scene has been presented, we do them within the scene's onAppear()
     * or onSetup() callbacks. When a scene is presented, the order of
     * execution is:
     *   OnSetup() -> transitions -> OnAppear()
     * If there are no transitions, such as a scene sliding in, then
     * it makes no difference if you put code in OnSetup() or OnAppear().
     */
    preparationScene.onAppear(() => {
      preparationScene.run(
        Action.sequence([
          Action.wait({
            duration: game.getParameter("preparation_duration_ms"),
          }),
          // Custom actions are used execute code.
          Action.custom({
            callback: () => {
              game.presentScene(presentationScene);
            },
          }),
        ]),
      );
    });

    /**
     * ************************************************************************
     * Scene: presentation. Present the word and get user selection
     */    
    const presentationScene = new Scene();
    game.addScene(presentationScene);

    presentationScene.onAppear(() => {
  // Start the RT timer
  Timer.startNew("responseTime");

  // Grab the current trial’s configuration
  const idx = game.trialIndex;
  const trialConfiguration = trialConfigurations[idx];

  // Create the circular button (centered at x=200, y=400)
  const button = new Button({
    text: trialConfiguration.presented_letter,
    size: { width: 100, height: 100 },
    cornerRadius: 50,
    fontColor: WebColors.White,
    backgroundColor: WebColors.Blue,
    position: { x: 200, y: 400 },
    isUserInteractionEnabled: true,
  });
  presentationScene.addChild(button);

  let hasResponded = false;
  let timeoutHandle: ReturnType<typeof setTimeout>;

  // If the user taps before timeout
  button.onTapDown(() => {
    if (hasResponded) return;
    handleUserSelection();
  });

  function handleUserSelection(): void {
    // Prevent double‐taps
    button.isUserInteractionEnabled = false;
    hasResponded = true;

    // Cancel the pending timeout
    clearTimeout(timeoutHandle);

    // Stop the RT timer and record RT
    Timer.stop("responseTime");
    const rt = Timer.elapsed("responseTime");
    Timer.remove("responseTime");

    // Add trial data
    game.addTrialData("trial_index", idx);
    game.addTrialData("presented_letter_text", trialConfiguration.presented_letter);
    game.addTrialData("presented_letter_nogo", trialConfiguration.presented_isnogo);
    game.addTrialData("response_time_ms", rt);

    // If letter was "X" (no-go) but user tapped → incorrect. Otherwise correct.
    const correct = !trialConfiguration.presented_isnogo;
    game.addTrialData("selection_correct", correct);

    // Remove the button and advance
    presentationScene.removeChildren([button]);
    game.trialComplete();

    if (game.trialIndex === game.getParameter<number>("number_of_trials")) {
      game.presentScene(doneScene);
    } else {
      game.presentScene(preparationScene);
    }
  }

  // Separate function to handle when the user does NOT tap within the time window
  function handleUserTimeout(): void {
    if (hasResponded) return;
    hasResponded = true;

    // Record “no response”
    game.addTrialData("trial_index", idx);
    game.addTrialData("presented_letter_text", trialConfiguration.presented_letter);
    game.addTrialData("presented_letter_nogo", trialConfiguration.presented_isnogo);
    game.addTrialData("response_time_ms", 1500);

    // If letter was "X" (no-go), then withholding is correct; otherwise it's a miss
    const correct = trialConfiguration.presented_isnogo;
    game.addTrialData("selection_correct", correct);

    // Remove button and advance
    presentationScene.removeChildren([button]);
    game.trialComplete();

    if (game.trialIndex === game.getParameter<number>("number_of_trials")) {
      game.presentScene(doneScene);
    } else {
      game.presentScene(preparationScene);
    }
  }

  // Schedule the timeout using the same parameter as “letter‐shown” duration
  timeoutHandle = setTimeout(
    handleUserTimeout,
    game.getParameter<number>("selection_duration_ms") // 1500 ms by default
  );
});


    /**
     * ************************************************************************
     * Scene: done. Show done message, with a button to exit.
     */       
    const doneScene = new Scene();
    game.addScene(doneScene);

    const doneSceneText = new Label({
      text: "You have completed all the Letter Go-No Go trials",
      position: { x: 200, y: 400 },
    });
    doneScene.addChild(doneSceneText);

    const okButton = new Button({
      text: "OK",
      position: { x: 200, y: 600 },
    });
    okButton.isUserInteractionEnabled = true;
    okButton.onTapDown(() => {
      // Don't allow repeat taps of ok button
      okButton.isUserInteractionEnabled = false;
      doneScene.removeAllChildren();
      /**
       * When the game is done, you must call game.end() to transfer control
       * back to the Session, which will then start the next activity or
       * send a session end event to the event subscribers.
       */
      game.end();
    });
    doneScene.addChild(okButton);
  }
}

const activity = new LetterGoNoGo();

// Set game parameters from URL parameters. Delete if this is not wanted.
const urlParams = new URLSearchParams(window.location.search);
const gameParameters: { [key: string]: string } = {};
urlParams.forEach((value, key) => {
  gameParameters[key] = value;
});
activity.setParameters(gameParameters);

const activities = [activity];
const session = new Session({
  activities: activities,
});

/**
 * An event handler provided to session.onActivityData() will be called
 * when a trial or survey question is completed. It will be passed an
 * ActivityResultsEvent object, which is named ev in the example below.
 * 
 * The event handler is where you insert code to post data to an API or, in
 * the example below, simply log the data to the console.
 *
 * ev.newData is the data that was just generated by the completed trial or
 * survey question.
 * ev.data is all the data, cumulative of all trials or questions in the
 * activity, that have been generated.
 *
 * We separate out newData from data in case you want to alter the execution
 * based on the most recent trial, e.g., maybe you want to stop after
 * a certain user behavior or performance threshold in the just completed
 * trial.
 *
 * ev.activityConfiguration is the game parameters that were used.
 *
 * The schema for all of the above are in JSON Schema format.
 * Currently, only games generate schema.
 */
session.onActivityData((ev) => {
  if (ev.target.type === ActivityType.Game) {
    console.log(`✅ trial completed:`);
  } else if (ev.target.type === ActivityType.Survey) {
    console.log(`✅ survey response completed:`);
  }
  console.log("  newData: " + JSON.stringify(ev.newData));
  console.log("  newData schema: " + JSON.stringify(ev.newDataSchema));
  console.log("  data: " + JSON.stringify(ev.data));
  console.log("  data schema: " + JSON.stringify(ev.dataSchema));
  console.log(
    "  activity parameters: " + JSON.stringify(ev.activityConfiguration)
  );
  console.log(
    "  activity parameters schema: " +
      JSON.stringify(ev.activityConfigurationSchema)
  );  
});

/**
 * Make session also available on window in case we want to control
 * the session through another means, such as other javascript or
 * browser code, or a mobile WebView.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
(window as unknown as any).m2c2kitSession = session;
session.initialize();
